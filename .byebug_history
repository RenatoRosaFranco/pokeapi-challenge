exit
c
cache_key
resuresult
result = FetchApiInteractor.call(data: params[:name].downcase);
params[:name].downcase.to_s
params[:name].downcase
params[:name]
c
cached_data.nil?
cached_data
cache_key
c
context.error
context
        expect(context).to be_a_failure
exit
        expect(context.pokemon).not_to be_empty
        expect(context).to be_a_success
context
exit
expect(response_body).to include({error: err_message})
response_body == {"error" => "Pokemon not found" }
response_body == {"errpr" => err_message}
response_body
response.body
expect(response_body).include({"error" => err_message})
c
response_body.with_indifferent_access
response_body.hasWithIndiferentAcess
response_body
response_bodyrespon
response_body
exit
response.body
        expect(response).to have_http_status(:not_found)
response.code
response.cde
response.status_code
response
name
c
expect(JSON.parse(response.body)).to include(pokemon)
pokemon
exit
pokemon.as_json
pokemon
body = JSON.parse(response.body)
body = JSON.parse
expect(response).to have_http_status(:success)
expect(JSON.parse(response.body)).not_to be_empty
        expect(JSON.response(response.body)).not_to be_empty
        expect(response).to have_http_status(:success)
response.body
response
exit
    before do
      get "/api/v1/pokemon/#{name}"
    end
get "/api/v1/pokemon/#{name}"
'/api/v1/pokemon/#{name}'
get "api/v1/pokemon/#{name}"
get '/api/v1/pokemon/pikachu'
get '/api/v1/pokemon'
get '/api/v1/'
get '/api'
get 'localhost:3000'
get ''
get :index
exit
get :index, params:  { url: "#{ENV.fetch('API_URL')}v1/pokemon/#{name}" }
      get :index,
        params:  {
          url: "#{ENV.fetch('API_URL')}v1/pokemon/#{name}"
        }
get :index, url: "#{ENV.fetch('API_URL')}v1/pokemon/#{name}"
get :index, path: "#{ENV.fetch('API_URL')}v1/pokemon/#{name}"
get :index, url: "#{ENV.fetch('API_URL')}v1/pokemon/#{name}"
"#{ENV.fetch('API_URL')}v1/pokemon/#{name}"
url: "#{ENV.fetch('API_URL')}v1/pokemon/#{name}"
"#{ENV.fetch('API_URL')}v1/pokemons/#{name}"
"#{ENV.fetch('API_URL')}/v1/pokemons/#{name}"
ENV.fetch('API_URL')
exit
exi
get 'localhost:3000/api/v1/pokemons/'
get '/api/v1/pokemons/'
get '/api/v1/pokemons'
get '/api/v1'
get :index
c
result.status_code
result
exit
ap context
e
c
    context.pokemon = poke_api_client.pokemon
    poke_api_client = Http::PokemonApiService.new(data)
data
c
exit
JSON.parse(:status_code => 200)
JSON.parse(status_code: 200)
JSON.parse({status_code: 200})
JSON.parse({})
response.status_code
response.code
    response = poke_api_client.pokemon
poke_api_client = Http::PokemonApiService.new(data)
c
data
context.pokemon
context.pokemon = poke_api_client.pokemon
context.pokemon
context.pokemon = poke_api_client.pokemon
poke_api_client = Http::PokemonApiService.new(data)
c
FetchApiInteractor.call(data: data)
c
result.error.
result.error
result.success?
c
result      = FetchApiInteractor.call(data: data)
data        = params[:name]
params[:name]
exit
raise RestClient::NotFound, 'nao achei'
response.code
response.code == 404
response.code == '200'
response.code == 200
response.code
response.body
response
response = self.class.get("/v2/pokemon/#{@name}", @options)
c
PokemonSerializer.new(result.pokemon).serializable_hash
exit
    self.object['abilities'].map do |abilities|
      abilities['ability']['name']
    end.sort
    self.object['abilities'].map do |abilities|
      abilities['ability']['name']
    end
self.object['abilities'].empty?
self.object['abilities']
self.object
self.object['attributes']
self.object
self
c
exit
data['abilities'].each {|ability| puts ability['ability']['name'] }.uniq!
data['abilities'].each {|ability| puts ability['ability']['name'] }
data['abilities'].each {|ability| ability['ability']['name'] }
data['abilities'].each {|ability| ability['ability'] }
data['abilities'].each {|ability| ability.name }
data['abilities'].each {|ability|}
data['abilities'].count
data['abilities']
data
result = data['abitilies'].each { |ability| ability.name }
data['abilities']
data['abilities'].count
data['abilities']
data
exit
ap data
    data = JSON.parse(response.body)
    data = JSON.parse(response.data)
response.body
response.headers.inspect
response.headers
response.message
response.code
response.status
response = self.class.get('/v2/pokemon/', query: { name: 'ditto' })
response.status
response.status_code
self.class.get('/v2/pokemon/', query: { name: 'ditto' })
self.class.get('v2/pokemon/', query: { name: 'ditto' })
self.class.get('/v2/pokemon/', query: { name: 'ditto' })
self.class.get
response = self.class.get('v2/pokemon/', @options)
c
@options
response.code
response = self.class.get('v2/pokemon/', @options)
exit
exut
request = self.class.get('v2/pokemon/', @options)
exit
self.class.get('/v2/pokemon/', { query: { name: 'ditto', page: 1 }})
self.class.get('/v2/pokemon/', { query: { name: 'ditto', page: 2 }})
self.class.get('/v2/pokemon/', { query: { name: 'ditto' }})
self.class.get('/v2/pokemon/', { query: { name: 'ditto' })
self.class.get('/v2/pokemon/ditto', {})
self.class.get('', {})
self.class.get('', nil)
self.class.get
self.class
